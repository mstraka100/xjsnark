package xjsnark.zerocash;

/*Generated by MPS */

import backend.structure.CircuitGenerator;
import backend.config.Config;
import backend.eval.SampleRun;
import java.math.BigInteger;
import backend.auxTypes.UnsignedInteger;
import backend.eval.CircuitEvaluator;

public class PourCircuit extends CircuitGenerator {



  public static void main(String[] args) {
    Config.multivariateExpressionMinimization = true;

    // Number of threads should be at most (numFreeProcessors - 1), otherwise faster time outs could happen 
    Config.arithOptimizerNumThreads = 2;
    Config.arithOptimizerTimeoutPerProblemMilliSec = 20000;
    Config.outputVerbose = false;
    Config.inputVerbose = false;

    // To run the circuit with height = 64 
    // - If the multivariate optimizer is enabled, it will require high memory usage (about 7G  
    //  according to experiments. 
    // To optimize the whole circuit. It will be difficult to run it through the IDE directly, but 
    // the output java files (after compilation/transformation) can be easily exported to run externally 
    // on any EC2 machine, with the back end jar. Instructions are on Github. 
    new PourCircuit();
  }

  public PourCircuit() {
    super("PourCircuit");
    __generateCircuit();
    this.__evaluateSampleRun(new SampleRun("SampleTest1", true) {
      public void pre() {

        // Generating some random values 
        sample = new PourCircuitSampleIO(HEIGHT);

        for (int i = 0; i < 8; i++) {
          h_sig.array[i].mapValue(TestUtilities.intToUnsignedBigInteger(sample.getH_sig()[i]), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
        }
        for (int i = 0; i < 8; i++) {
          root.array[i].mapValue(TestUtilities.intToUnsignedBigInteger(sample.getMerkleTree().getRoot()[i]), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
        }

        authPath1.directionSelector.mapValue(BigInteger.valueOf(sample.getIndex1()), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
        authPath2.directionSelector.mapValue(BigInteger.valueOf(sample.getIndex2()), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());

        for (int j = 0; j < HEIGHT; j++) {
          for (int i = 0; i < 8; i++) {
            authPath1.digests[j].array[i].mapValue(TestUtilities.intToUnsignedBigInteger(sample.getAuthPath1()[j][i]), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
            authPath2.digests[j].array[i].mapValue(TestUtilities.intToUnsignedBigInteger(sample.getAuthPath2()[j][i]), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
          }
        }

        for (int i = 0; i < 8; i++) {
          c1_old.rho[i].mapValue(TestUtilities.intToUnsignedBigInteger(sample.getOldCoinComm1().getCoin().getRho()[i]), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
          c1_new.rho[i].mapValue(TestUtilities.intToUnsignedBigInteger(sample.getNewCoinComm1().getCoin().getRho()[i]), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
          c2_old.rho[i].mapValue(TestUtilities.intToUnsignedBigInteger(sample.getOldCoinComm2().getCoin().getRho()[i]), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
          c2_new.rho[i].mapValue(TestUtilities.intToUnsignedBigInteger(sample.getNewCoinComm2().getCoin().getRho()[i]), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
          c1_old_comm.array[i].mapValue(TestUtilities.intToUnsignedBigInteger(sample.getOldCoinComm1().getDigest()[i]), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
          c2_old_comm.array[i].mapValue(TestUtilities.intToUnsignedBigInteger(sample.getOldCoinComm2().getDigest()[i]), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());


          c1_old.pubKey.a_pk.array[i].mapValue(TestUtilities.intToUnsignedBigInteger(sample.getOldCoinComm1().getCoin().getPubKey().getA_pk()[i]), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
          c2_old.pubKey.a_pk.array[i].mapValue(TestUtilities.intToUnsignedBigInteger(sample.getOldCoinComm2().getCoin().getPubKey().getA_pk()[i]), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
          c1_new.pubKey.a_pk.array[i].mapValue(TestUtilities.intToUnsignedBigInteger(sample.getNewCoinComm1().getCoin().getPubKey().getA_pk()[i]), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
          c2_new.pubKey.a_pk.array[i].mapValue(TestUtilities.intToUnsignedBigInteger(sample.getNewCoinComm2().getCoin().getPubKey().getA_pk()[i]), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());


          sk1_old.a_sk[i].mapValue(TestUtilities.intToUnsignedBigInteger(sample.getOldCoinComm1().getCoin().getPubKey().getSk().getA_sk()[i]), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
          sk2_old.a_sk[i].mapValue(TestUtilities.intToUnsignedBigInteger(sample.getOldCoinComm2().getCoin().getPubKey().getSk().getA_sk()[i]), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());

        }

        for (int i = 0; i < 12; i++) {
          c1_old.rand[i].mapValue(TestUtilities.intToUnsignedBigInteger(sample.getOldCoinComm1().getCoin().getRand()[i]), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
          c1_new.rand[i].mapValue(TestUtilities.intToUnsignedBigInteger(sample.getNewCoinComm1().getCoin().getRand()[i]), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
          c2_old.rand[i].mapValue(TestUtilities.intToUnsignedBigInteger(sample.getOldCoinComm2().getCoin().getRand()[i]), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
          c2_new.rand[i].mapValue(TestUtilities.intToUnsignedBigInteger(sample.getNewCoinComm2().getCoin().getRand()[i]), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
        }

        pubVal.mapValue(sample.getPubVal(), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
        c1_old.value.mapValue(sample.getOldCoinComm1().getCoin().getValue(), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
        c2_old.value.mapValue(sample.getOldCoinComm2().getCoin().getValue(), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());

        c1_new.value.mapValue(sample.getNewCoinComm1().getCoin().getValue(), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
        c2_new.value.mapValue(sample.getNewCoinComm2().getCoin().getValue(), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());

      }
      public void post() {

        System.out.println("Post Completion: No failed assertions or exceptions should appear above. See SampleRun.");
        for (int i = 0; i < 8; i++) {
          if (!(sn1_old.array[i].getValueFromEvaluator(CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator()).equals(TestUtilities.intToUnsignedBigInteger(sample.getSn1()[i])))) {
            throw new RuntimeException("Unexpected Serial Number(1) Value");
          }
          if (!(sn2_old.array[i].getValueFromEvaluator(CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator()).equals(TestUtilities.intToUnsignedBigInteger(sample.getSn2()[i])))) {
            throw new RuntimeException("Unexpected Serial Number(2) Value");
          }
          if (!(c1_new_comm.array[i].getValueFromEvaluator(CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator()).equals(TestUtilities.intToUnsignedBigInteger(sample.getNewCoinComm1().digest[i])))) {
            throw new RuntimeException("Unexpected New Commitment(1) Value");
          }
          if (!(c2_new_comm.array[i].getValueFromEvaluator(CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator()).equals(TestUtilities.intToUnsignedBigInteger(sample.getNewCoinComm2().digest[i])))) {
            throw new RuntimeException("Unexpected New Commitment(2) Value");
          }
          if (!(h1.array[i].getValueFromEvaluator(CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator()).equals(TestUtilities.intToUnsignedBigInteger(sample.getH1()[i])))) {
            throw new RuntimeException("Unexpected H1 Value");
          }
          if (!(h2.array[i].getValueFromEvaluator(CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator()).equals(TestUtilities.intToUnsignedBigInteger(sample.getH2()[i])))) {
            throw new RuntimeException("Unexpected H2 Value");
          }
        }

      }

    });

  }



  public void __init() {
    root = new Digest();
    authPath1 = new MerkleAuthPath();
    authPath2 = new MerkleAuthPath();
    c1_old = new Coin();
    c2_old = new Coin();
    c1_new = new Coin();
    c2_new = new Coin();
    sn1_old = new Digest();
    sn2_old = new Digest();
    c1_old_comm = new Digest();
    c2_old_comm = new Digest();
    c1_new_comm = new Digest();
    c2_new_comm = new Digest();
    sk1_old = new PrivateKey();
    sk2_old = new PrivateKey();
    h1 = new Digest();
    h2 = new Digest();
    h_sig = new Digest();
    pubVal = new UnsignedInteger(64, new BigInteger("0"));
  }

  private Digest root;
  private MerkleAuthPath authPath1;
  private MerkleAuthPath authPath2;
  private Coin c1_old;
  private Coin c2_old;
  private Coin c1_new;
  private Coin c2_new;
  private Digest sn1_old;
  private Digest sn2_old;
  private Digest c1_old_comm;
  private Digest c2_old_comm;
  private Digest c1_new_comm;
  private Digest c2_new_comm;
  private PrivateKey sk1_old;
  private PrivateKey sk2_old;
  private Digest h1;
  private Digest h2;
  private Digest h_sig;
  private UnsignedInteger pubVal;
  private PourCircuitSampleIO sample;

  public static final int HEIGHT = 8;
  @Override
  public void __defineInputs() {
    super.__defineInputs();
    pubVal = UnsignedInteger.createInput(this, 64);





    root.__makeInput();
    h_sig.__makeInput();


  }
  @Override
  public void __defineOutputs() {
    super.__defineOutputs();



    sn1_old.__makeOutput();
    sn2_old.__makeOutput();
    c1_new_comm.__makeOutput();
    c2_new_comm.__makeOutput();
    h1.__makeOutput();
    h2.__makeOutput();




  }
  @Override
  public void __defineVerifiedWitnesses() {
    super.__defineVerifiedWitnesses();






    authPath1.__makeVerifiedWitness();
    authPath2.__makeVerifiedWitness();
    c1_old.__makeVerifiedWitness();
    c2_old.__makeVerifiedWitness();
    c1_new.__makeVerifiedWitness();
    c2_new.__makeVerifiedWitness();
    c1_old_comm.__makeVerifiedWitness();
    c2_old_comm.__makeVerifiedWitness();
    sk1_old.__makeVerifiedWitness();
    sk2_old.__makeVerifiedWitness();




  }
  @Override
  public void __defineWitnesses() {
    super.__defineWitnesses();









  }
  public void outsource() {
    // verifying that the commitments have appeared before on the ledger 
    authPath1.computeMerkleRoot(c1_old_comm).assertEqual(root);
    authPath2.computeMerkleRoot(c2_old_comm).assertEqual(root);

    // verify the knowedlge of the secret keys 
    c1_old.pubKey.a_pk.assertEqual(PRF("addr", sk1_old.a_sk, new UnsignedInteger[]{new UnsignedInteger(32, new BigInteger("0")), new UnsignedInteger(32, new BigInteger("0")), new UnsignedInteger(32, new BigInteger("0")), new UnsignedInteger(32, new BigInteger("0")), new UnsignedInteger(32, new BigInteger("0")), new UnsignedInteger(32, new BigInteger("0")), new UnsignedInteger(32, new BigInteger("0")), new UnsignedInteger(32, new BigInteger("0"))}));
    c2_old.pubKey.a_pk.assertEqual(PRF("addr", sk2_old.a_sk, new UnsignedInteger[]{new UnsignedInteger(32, new BigInteger("0")), new UnsignedInteger(32, new BigInteger("0")), new UnsignedInteger(32, new BigInteger("0")), new UnsignedInteger(32, new BigInteger("0")), new UnsignedInteger(32, new BigInteger("0")), new UnsignedInteger(32, new BigInteger("0")), new UnsignedInteger(32, new BigInteger("0")), new UnsignedInteger(32, new BigInteger("0"))}));

    // Compute old coins serial numbers (this avoids double spending) 
    sn1_old = PRF("sn", sk1_old.a_sk, c1_old.rho);
    sn2_old = PRF("sn", sk2_old.a_sk, c2_old.rho);

    // verify old commitments and compute the new ones 
    c1_old_comm.assertEqual(COMM_s(COMM_r(c1_old.rand, c1_old.pubKey.a_pk.array, c1_old.rho).array, c1_old.value.copy(64)));
    c2_old_comm.assertEqual(COMM_s(COMM_r(c2_old.rand, c2_old.pubKey.a_pk.array, c2_old.rho).array, c2_old.value.copy(64)));
    c1_new_comm = COMM_s(COMM_r(c1_new.rand, c1_new.pubKey.a_pk.array, c1_new.rho).array, c1_new.value.copy(64));
    c2_new_comm = COMM_s(COMM_r(c2_new.rand, c2_new.pubKey.a_pk.array, c2_new.rho).array, c2_new.value.copy(64));

    // verifying the correct flow of money 
    c1_old.value.add(c2_old.value).forceEqual(c1_new.value.add(c2_new.value).add(pubVal));

    // verifying there are no overflows (the positivity of the values is guaranteed by the backend) 

    UnsignedInteger sum = UnsignedInteger.instantiateFrom(65, c1_old.value).add(c2_old.value).copy(65);
    UnsignedInteger mask = new UnsignedInteger(65, new BigInteger("18446744073709551616")).copy(65);
    sum.andBitwise(mask).forceEqual(new UnsignedInteger(1, new BigInteger("0")));

    // Hashes for non-malleability 
    // 3 bits from h_sig are truncated (SEE page 23 in  
    // http://zerocash-project.org/media/pdf/zerocash-extended-20140518.pdf ) 
    // we truncate 1 here, and 2 are already truncated later in PRF() 
    UnsignedInteger[] h_sigTruncated = truncate(h_sig.array, 1);
    h1 = PRF("pk", sk1_old.a_sk, h_sigTruncated);
    h_sigTruncated[0].assign(h_sigTruncated[0].orBitwise(new UnsignedInteger(32, new BigInteger("2147483648"))), 32);
    h2 = PRF("pk", sk2_old.a_sk, h_sigTruncated);

  }
  private Digest PRF(String type, UnsignedInteger[] x, UnsignedInteger[] z) {

    // truncate 2 least significant bits 
    // See page 22 in  http://zerocash-project.org/media/pdf/zerocash-extended-20140518.pdf  
    z = truncate(z, 2);
    UnsignedInteger mask = new UnsignedInteger(0, new BigInteger("0")).copy(32);
    if (type.equals("addr")) {
      mask.assign(new UnsignedInteger(0, new BigInteger("0")), 32);
    } else if (type.equals("sn")) {
      mask.assign(new UnsignedInteger(31, new BigInteger("1073741824")), 32);
    } else if (type.equals("pk")) {
      mask.assign(new UnsignedInteger(32, new BigInteger("2147483648")), 32);
    }

    UnsignedInteger[] input = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{16}, 32);
    for (int i = 0; i < 16; i++) {
      if (i < 8) {
        input[i].assign(x[i], 32);
      } else if (i == 8) {
        input[i].assign(z[i - 8].orBitwise(mask), 32);
      } else {
        input[i].assign(z[i - 8], 32);
      }
    }
    return Util.sha2(input);
  }
  private Digest COMM_r(UnsignedInteger[] r, UnsignedInteger[] a_pk, UnsignedInteger[] rho) {
    UnsignedInteger[] input1 = Util.concat(a_pk, 0, a_pk.length, rho, 0, rho.length);
    UnsignedInteger[] out1 = Util.sha2(input1).array;
    UnsignedInteger[] input2 = Util.concat(r, 0, r.length, out1, 0, out1.length / 2);
    return Util.sha2(input2);
  }
  private Digest COMM_s(UnsignedInteger[] k, UnsignedInteger val) {
    UnsignedInteger[] paddedVal = new UnsignedInteger[]{new UnsignedInteger(32, new BigInteger("0")), new UnsignedInteger(32, new BigInteger("0")), new UnsignedInteger(32, new BigInteger("0")), new UnsignedInteger(32, new BigInteger("0")), new UnsignedInteger(32, new BigInteger("0")), new UnsignedInteger(32, new BigInteger("0")), UnsignedInteger.instantiateFrom(32, (val.shiftRight(32))).copy(32), UnsignedInteger.instantiateFrom(32, val).copy(32)};
    UnsignedInteger[] input = Util.concat(k, 0, k.length, paddedVal, 0, paddedVal.length);
    return Util.sha2(input);
  }
  private UnsignedInteger[] truncate(UnsignedInteger[] words, int n) {

    if (n > 32 || n < 0) {
      throw new IllegalArgumentException("Invalid truncation argument");
    }
    UnsignedInteger[] t = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{words.length}, 32);
    for (int i = 0; i < words.length; i++) {
      t[i].assign(words[i], 32);
    }
    t[words.length - 1].assign(t[words.length - 1].shiftRight(n), 32);
    for (int i = words.length - 2; i >= 0; i--) {
      t[i + 1].assign(t[i + 1].orBitwise((t[i].shiftLeft((32 - n)))), 32);
      t[i].assign(t[i].shiftRight(n), 32);
    }
    return t;
  }

  public void __generateSampleInput(CircuitEvaluator evaluator) {
    __generateRandomInput(evaluator);
  }

}
