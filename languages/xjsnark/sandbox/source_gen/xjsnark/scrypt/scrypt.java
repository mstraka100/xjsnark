package xjsnark.scrypt;

/*Generated by MPS */

import backend.structure.CircuitGenerator;
import backend.config.Config;
import backend.eval.SampleRun;
import java.math.BigInteger;
import backend.auxTypes.UnsignedInteger;
import backend.auxTypes.SmartMemory;
import backend.eval.CircuitEvaluator;

public class scrypt extends CircuitGenerator {



  public static void main(String[] args) {
    // This is the java main method. Its purpose is to make the Progam runnable in the environment 

    Config.multivariateExpressionMinimization = true;

    // Num of threads could be set higher based on the machine specs. Setting it too high will lead to faster timeouts 
    Config.arithOptimizerNumThreads = 1;
    Config.arithOptimizerTimeoutPerProblemMilliSec = 20000;


    new scrypt();
  }

  public scrypt() {
    super("scrypt");
    __generateCircuit();
    this.__evaluateSampleRun(new SampleRun("Sample_Run1", true) {
      public void pre() {
        input[0].mapValue(BigInteger.valueOf(0x61626380), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
        for (int i = 1; i < 19; i++) {
          input[i].mapValue(BigInteger.valueOf(0), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
        }
        input[19].mapValue(BigInteger.valueOf(0x18), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
      }
      public void post() {
        // expected digest 
      }

    });

  }



  public void __init() {
    input = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{20}, 32);
  }

  public UnsignedInteger[] input;
  public UnsignedInteger[] digest;

  public static final long[] K_CONST = {1116352408L, 1899447441L, 3049323471L, 3921009573L, 961987163L, 1508970993L, 2453635748L, 2870763221L, 3624381080L, 310598401L, 607225278L, 1426881987L, 1925078388L, 2162078206L, 2614888103L, 3248222580L, 3835390401L, 4022224774L, 264347078L, 604807628L, 770255983L, 1249150122L, 1555081692L, 1996064986L, 2554220882L, 2821834349L, 2952996808L, 3210313671L, 3336571891L, 3584528711L, 113926993L, 338241895L, 666307205L, 773529912L, 1294757372L, 1396182291L, 1695183700L, 1986661051L, 2177026350L, 2456956037L, 2730485921L, 2820302411L, 3259730800L, 3345764771L, 3516065817L, 3600352804L, 4094571909L, 275423344L, 430227734L, 506948616L, 659060556L, 883997877L, 958139571L, 1322822218L, 1537002063L, 1747873779L, 1955562222L, 2024104815L, 2227730452L, 2361852424L, 2428436474L, 2756734187L, 3204031479L, 3329325298L};
  public static final long[] H_CONST = {1779033703L, 3144134277L, 1013904242L, 2773480762L, 1359893119L, 2600822924L, 528734635L, 1541459225L};
  @Override
  public void __defineInputs() {
    super.__defineInputs();







  }
  @Override
  public void __defineOutputs() {
    super.__defineOutputs();
    UnsignedInteger.makeOutput(this, digest);







  }
  @Override
  public void __defineVerifiedWitnesses() {
    super.__defineVerifiedWitnesses();

    input = UnsignedInteger.createVerifiedWitnessArray(this, input.length, 32);









  }
  @Override
  public void __defineWitnesses() {
    super.__defineWitnesses();









  }
  public static UnsignedInteger rotr(UnsignedInteger in, int r) {
    return (in.shiftRight(r)).orBitwise((in.shiftLeft((32 - r))));
  }
  public static UnsignedInteger rotl(UnsignedInteger in, int l) {
    return (in.shiftLeft(l)).orBitwise((in.shiftRight((32 - 1))));
  }
  public static UnsignedInteger[] SHA256(UnsignedInteger[] preimage) {
    UnsignedInteger[] H = UnsignedInteger.instantiateFrom(32, H_CONST);

    for (int i = 0; i < preimage.length / 16; i++) {
      UnsignedInteger[] words = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{64}, 32);
      UnsignedInteger a = H[0].copy(32);
      UnsignedInteger b = H[1].copy(32);
      UnsignedInteger c = H[2].copy(32);
      UnsignedInteger d = H[3].copy(32);
      UnsignedInteger e = H[4].copy(32);
      UnsignedInteger f = H[5].copy(32);
      UnsignedInteger g = H[6].copy(32);
      UnsignedInteger h = H[7].copy(32);

      for (int j = 0; j < 16; j++) {
        words[j].assign(preimage[j + i * 16], 32);
      }

      for (int j = 16; j < 64; j++) {
        UnsignedInteger s0 = rotr(words[j - 15].copy(32), 7).xorBitwise(rotr(words[j - 15].copy(32), 18)).xorBitwise((words[j - 15].shiftRight(3))).copy(32);
        UnsignedInteger s1 = rotr(words[j - 2].copy(32), 17).xorBitwise(rotr(words[j - 2].copy(32), 19)).xorBitwise((words[j - 2].shiftRight(10))).copy(32);
        words[j].assign(words[j - 16].add(s0).add(words[j - 7]).add(s1), 32);
      }
      for (int j = 0; j < 64; j++) {
        UnsignedInteger s0 = rotr(a.copy(32), 2).xorBitwise(rotr(a.copy(32), 13)).xorBitwise(rotr(a.copy(32), 22)).copy(32);
        UnsignedInteger maj = (a.andBitwise(b)).xorBitwise((a.andBitwise(c))).xorBitwise((b.andBitwise(c))).copy(32);
        UnsignedInteger t2 = s0.add(maj).copy(32);

        UnsignedInteger s1 = rotr(e.copy(32), 6).xorBitwise(rotr(e.copy(32), 11)).xorBitwise(rotr(e.copy(32), 25)).copy(32);
        UnsignedInteger ch = e.andBitwise(f).xorBitwise(e.invBits().andBitwise(g)).copy(32);
        UnsignedInteger t1 = h.add(s1).add(ch).add(UnsignedInteger.instantiateFrom(32, K_CONST[j])).add(words[j]).copy(32);
        h.assign(g, 32);
        g.assign(f, 32);
        f.assign(e, 32);
        e.assign(d.add(t1), 32);
        d.assign(c, 32);
        c.assign(b, 32);
        b.assign(a, 32);
        a.assign(t1.add(t2), 32);
      }
      H[0].assign(H[0].add(a), 32);
      H[1].assign(H[1].add(b), 32);
      H[2].assign(H[2].add(c), 32);
      H[3].assign(H[3].add(d), 32);
      H[4].assign(H[4].add(e), 32);
      H[5].assign(H[5].add(f), 32);
      H[6].assign(H[6].add(g), 32);
      H[7].assign(H[7].add(h), 32);
    }
    return H;
  }
  public UnsignedInteger[] concat_arrays(UnsignedInteger[] a, UnsignedInteger[] b) {
    UnsignedInteger[] result = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{a.length + b.length}, 32);
    for (int i = 0; i < a.length; i++) {
      result[i].assign(a[i], 32);
    }
    for (int i = 0; i < b.length; i++) {
      result[a.length + i].assign(b[i], 32);
    }
    return result;
  }
  public static UnsignedInteger[] pad_sha_input(UnsignedInteger[] arr) {
    int words_to_fill = 16 - (arr.length % 16);
    UnsignedInteger[] result = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{arr.length + words_to_fill}, 32);
    for (int i = 0; i < arr.length; i++) {
      result[i].assign(arr[i], 32);
    }
    for (int i = arr.length; i < result.length; i++) {
      result[i].assign(new UnsignedInteger(32, new BigInteger("0")), 32);
    }
    return result;
  }
  public static UnsignedInteger[] HMAC_SHA256(UnsignedInteger[] k, UnsignedInteger[] m) {
    // pad or hash key to SHA256 block size 
    UnsignedInteger[] k_prime;
    if (k.length > 16) {
      k_prime = pad_sha_input(k);
    } else if (k.length < 16) {
      k_prime = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{16}, 32);
      for (int i = 0; i < k.length; i++) {
        k_prime[i].assign(k[i], 32);
      }
      for (int i = k.length + 1; i < 16; i++) {
        k_prime[i].assign(new UnsignedInteger(32, new BigInteger("0")), 32);
      }
    } else {
      k_prime = k;
    }

    // derive inner key with pad 909522486 = 0x36363636 
    UnsignedInteger ival = new UnsignedInteger(32, new BigInteger("909522486"));
    UnsignedInteger[] ikey = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{16}, 32);
    for (int i = 0; i < 16; i++) {
      ikey[i].assign(ival.xorBitwise(k_prime[i]), 32);
    }
    // derive outer key with pad 1549556828 = 0x5c5c5c5c 
    UnsignedInteger oval = new UnsignedInteger(32, new BigInteger("1549556828"));
    UnsignedInteger[] okey = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{16}, 32);
    for (int i = 0; i < 16; i++) {
      okey[i].assign(oval.xorBitwise(k_prime[i]), 32);
    }
    UnsignedInteger[] ihash = SHA256(ikey);

    // concat okey || ihash || m,hash and return result 
    UnsignedInteger[] oinput = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{16 + 8 + m.length}, 32);
    for (int i = 0; i < 16; i++) {
      oinput[i].assign(okey[i], 32);
    }
    for (int i = 16; i < 24; i++) {
      oinput[i].assign(ihash[i - 16], 32);
    }
    for (int i = 24; i < 24 + m.length; i++) {
      oinput[i].assign(m[i - 24], 32);
    }
    UnsignedInteger[] padded_oinput = pad_sha_input(oinput);

    return SHA256(padded_oinput);
  }
  public UnsignedInteger[] xor_salsa8(UnsignedInteger[] B, UnsignedInteger[] Bx) {
    UnsignedInteger[] x = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{16}, 32);
    for (int i = 0; i < 16; i++) {
      x[i].assign(B[i].xorBitwise(Bx[i]), 32);
    }
    for (int i = 0; i < 8; i += 2) {
      x[4].assign(x[4].xorBitwise(rotl(x[0].add(x[12]).copy(32), 7)), 32);
      x[9].assign(x[9].xorBitwise(rotl(x[5].add(x[1]).copy(32), 7)), 32);
      x[14].assign(x[14].xorBitwise(rotl(x[10].add(x[6]).copy(32), 7)), 32);
      x[3].assign(x[3].xorBitwise(rotl(x[15].add(x[11]).copy(32), 7)), 32);

      x[8].assign(x[8].xorBitwise(rotl(x[4].add(x[0]).copy(32), 9)), 32);
      x[13].assign(x[13].xorBitwise(rotl(x[9].add(x[5]).copy(32), 9)), 32);
      x[2].assign(x[2].xorBitwise(rotl(x[14].add(x[10]).copy(32), 9)), 32);
      x[7].assign(x[7].xorBitwise(rotl(x[3].add(x[15]).copy(32), 9)), 32);

      x[12].assign(x[12].xorBitwise(rotl(x[8].add(x[4]).copy(32), 13)), 32);
      x[1].assign(x[1].xorBitwise(rotl(x[13].add(x[9]).copy(32), 13)), 32);
      x[6].assign(x[6].xorBitwise(rotl(x[2].add(x[14]).copy(32), 13)), 32);
      x[11].assign(x[11].xorBitwise(rotl(x[7].add(x[3]).copy(32), 13)), 32);

      x[0].assign(x[0].xorBitwise(rotl(x[12].add(x[8]).copy(32), 18)), 32);
      x[5].assign(x[5].xorBitwise(rotl(x[1].add(x[13]).copy(32), 18)), 32);
      x[10].assign(x[10].xorBitwise(rotl(x[6].add(x[2]).copy(32), 18)), 32);
      x[15].assign(x[15].xorBitwise(rotl(x[11].add(x[7]).copy(32), 18)), 32);

      x[1].assign(x[1].xorBitwise(rotl(x[0].add(x[3]).copy(32), 7)), 32);
      x[6].assign(x[6].xorBitwise(rotl(x[5].add(x[4]).copy(32), 7)), 32);
      x[11].assign(x[11].xorBitwise(rotl(x[10].add(x[9]).copy(32), 7)), 32);
      x[12].assign(x[12].xorBitwise(rotl(x[15].add(x[14]).copy(32), 7)), 32);

      x[2].assign(x[2].xorBitwise(rotl(x[1].add(x[0]).copy(32), 9)), 32);
      x[7].assign(x[7].xorBitwise(rotl(x[6].add(x[5]).copy(32), 9)), 32);
      x[8].assign(x[8].xorBitwise(rotl(x[11].add(x[10]).copy(32), 9)), 32);
      x[13].assign(x[13].xorBitwise(rotl(x[12].add(x[15]).copy(32), 9)), 32);

      x[3].assign(x[3].xorBitwise(rotl(x[2].add(x[1]).copy(32), 13)), 32);
      x[4].assign(x[4].xorBitwise(rotl(x[7].add(x[6]).copy(32), 13)), 32);
      x[9].assign(x[9].xorBitwise(rotl(x[8].add(x[11]).copy(32), 13)), 32);
      x[14].assign(x[14].xorBitwise(rotl(x[13].add(x[12]).copy(32), 13)), 32);

      x[0].assign(x[0].xorBitwise(rotl(x[3].add(x[2]).copy(32), 18)), 32);
      x[5].assign(x[5].xorBitwise(rotl(x[4].add(x[7]).copy(32), 18)), 32);
      x[10].assign(x[10].xorBitwise(rotl(x[9].add(x[8]).copy(32), 18)), 32);
      x[15].assign(x[15].xorBitwise(rotl(x[14].add(x[13]).copy(32), 18)), 32);
    }
    for (int i = 0; i < 16; i++) {
      B[i].assign(B[i].add(x[i]), 32);
    }
    return B;
  }
  public static UnsignedInteger[] PBKDF2_SHA256(UnsignedInteger[] pwd, UnsignedInteger[] salt, int dkLen) {
    UnsignedInteger[] result = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{dkLen / 4}, 32);
    UnsignedInteger[] U = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{8}, 32);
    for (int i = 0; i * 32 < dkLen; i++) {
      // U_1 = HMAC(P, S || BEINT(i+1)), jvm big-endian by default 
      UnsignedInteger[] m = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{salt.length + 1}, 32);
      for (int j = 0; j < salt.length; j++) {
        m[j].assign(salt[j], 32);
      }
      m[m.length - 1].assign(UnsignedInteger.instantiateFrom(32, i + 1), 32);
      U = HMAC_SHA256(pwd, m);
      for (int j = i * 8; j < (i + 1) * 8; j++) {
        result[j].assign(U[j % 8], 32);
      }
    }
    return result;
  }
  public void outsource() {
    UnsignedInteger[] X = PBKDF2_SHA256(input, input, 128);
    UnsignedInteger[] X_one = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{16}, 32);
    UnsignedInteger[] X_two = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{16}, 32);
    UnsignedInteger[] V = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{1024 * 32}, 32);
    for (int i = 0; i < 16; i++) {
      X_one[i].assign(X[i], 32);
    }
    for (int i = 0; i < 16; i++) {
      X_two[i].assign(X[i + 16], 32);
    }
    // cache current value of X 
    for (int i = 0; i < 1024; i++) {
      for (int j = 0; j < 32; j++) {
        V[j + i * 32].assign(X[j], 32);
      }
      X_one = xor_salsa8(X_one, X_two);
      X_two = xor_salsa8(X_two, X_one);
      X = concat_arrays(X_one, X_two);
    }

    SmartMemory<UnsignedInteger> vRAM = new SmartMemory(V, UnsignedInteger.__getClassRef(), new Object[]{"32"});
    for (int i = 0; i < 1024; i++) {
      UnsignedInteger j = (X[16].andBitwise(new BigInteger("" + 1023))).mul(UnsignedInteger.instantiateFrom(32, 32)).copy(32);
      for (int k = 0; k < 32; k++) {
        X[k].assign(X[k].xorBitwise(vRAM.read(j.add(UnsignedInteger.instantiateFrom(32, k)))), 32);
      }
      X_one = xor_salsa8(X_one, X_two);
      X_two = xor_salsa8(X_two, X_one);
      X = concat_arrays(X_one, X_two);
    }
    digest = PBKDF2_SHA256(input, X, 32);
  }

  public void __generateSampleInput(CircuitEvaluator evaluator) {
    __generateRandomInput(evaluator);
  }

}
